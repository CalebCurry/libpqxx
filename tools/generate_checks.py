#! /usr/bin/env python3

"""Generate a C++ programme to check C++ feature macros.

The C++ code, when run, will produce a header describing available C++
features.

Unlike the standard C++ feature test macros, which are either undefined or
defined to 1, the libpqxx feature test macros will always have a definition.
This means you can check them without risking an "undefined macro" warning
when compiling under very strict settings.
"""

from argparse import (
    ArgumentParser,
    FileType,
)
from datetime import datetime
from pathlib import Path
import sys
from textwrap import dedent

if sys.version_info >= (3, 11):
    from datetime import UTC
else:
    from pytz import UTC
endif

HELP_EPILOGUE = dedent("""\
    Pass in the "cxx_features.txt" file, listing (one pair per line) the C++
    feature test macros that the programme should check, and the respective
    libpqxx macros that it should set accordingly.  Separate them with
    whitespace.
    """)


class Fail(Exception):
    """A well-handled but fatal exception.  No traceback."""


# Beginning of C++ code, for the case where we're writing to a header file.
# This is an f-string but it also takes interpolation of the header path.
HEAD_FILE = dedent("""\
    #include <fstream>

    int main()
    {
        std::ofstream("%s") <<
    """
)


# Beginning of C++ code, for the case where we're writing to standard output.
HEAD_STDOUT = dedent("""\
    #include <iostream>

    int main()
    {
        std::cout <<
    """
)


# Footer of the C+ code.
TAIL = dedent("""\
        << std::endl;
    }
    """)


# Path standin for standard output.
STDOUT_PATH = Path('-')


def parse_args():
    """Parse command-line arguments."""
    parser = ArgumentParser(description=__doc__)
    parser.add_argument(
        'input', metavar='PATH', type=FileType('r', encoding='ascii'),
        help=(
	    f"File listing feature test macros, or '{STDOUT_PATH}' for "
	    "standard input."))
    parser.add_argument(
        '--header', '-H', metavar='PATH', type=Path, default=STDOUT_PATH,
        help=(
            "Write configuration header to PATH, "
            f"or '{STDOUT_PATH}' for standard output (the default).")
    )
    parser.add_argument(
        '--dummy', '-d', action='store_true',
        help="Generate dummy header for manual editing, not C++ code.")
    return parser.parse_args()


def iterate_entries(instream):
    """Iterate pairs of standard C++ and libpqxx feature macros."""
    for line in instream:
        yield line.strip().split()


def generate_code(entries, header):
    """Generate C++ code for generating a header."""
    if header == STDOUT_PATH:
        print(HEAD_STDOUT)
    else:
        # XXX: Escape header path.
        print(HEAD_FILE % header)
    print("""\
        // Feature test macros for libpqxx.
        // Generated by generate_checks.py.
        """
    )

    for cxx_macro, pqxx_macro in entries:
        print(dedent(f"""\
            "#define {pqxx_macro} "
            #if defined({cxx_macro}) && {cxx_macro}
                "true"
            #else
                "false"
            #endif
            "\\n"
            """))
    print(TAIL)


def generate_dummy(entries, header):
    """Generate a dummy header."""
    if header == STDOUT_PATH:
        outfile = sys.stdout
    else:
        outfile = header.open('w', encoding='ascii')
    with outfile as stream:
        print(
	    "// Dummy settings for cross-compile.  Configure manually.",
	    file=stream
	)
        for _, pqxx_macro in entries:
            print(f"#define {pqxx_macro} false", file=stream)


def main():
    """Main entry point."""
    try:
        args = parse_args()
        entries = iterate_entries(args.input)
        if args.dummy:
            generate_dummy(entries, args.header)
        else:
            generate_code(entries, args.header)
    except Fail as error:
        print(error, file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
