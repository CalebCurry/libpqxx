#! /usr/bin/env python3

"""Generate C++ code to check C++ feature macros.

The configure step of a build will run the output through the C++
preprocessor, which will resolve preprocessor conditionals like
"does this compiler support library feature X?"
"""

from argparse import (
    ArgumentParser,
    FileType,
)
import os.path
import re
import sys


EPILOGUE = """\
Unlike the standard C++ feature test macros, which are either undefined or
defined to 1, the libpqxx feature test macros will always have a definition.
This means you can check them without risking an "undefined macro" warning
when compiling under very strict settings.
"""

class Fail(Exception):
    """A well-handled but fatal exception.  No traceback."""


def parse_args():
    """Parse command-line arguments."""
    parser = ArgumentParser(description=__doc__, epilog=EPILOGUE)
    parser.add_argument(
        '--static', '-s', action='store_true',
        help=(
            "Read as input a file of, one pair per line, C++ feature test "
            "macros and their respective libpqxx equivalents.  Generate as "
            "output C++ code ready to run through the preprocessor.  "
            "You must pass either this or '--config'."))
    parser.add_argument(
        '--config', '-c', action='store_true',
        help=(
            "Read as input a preprocessed vesrion of code originally "
            "generated by the '--static' option, and write as output a C++ "
            "header defining the libpqxx feature macros.  "
            "You must pass either this or '--static'."))
    parser.add_argument(
        '--input', '-i', metavar='PATH', type=FileType('r', encoding='ascii'),
        default='-',
        help="Input file, or '-' (the default) for standard input.")
    parser.add_argument(
        '--output', '-o', metavar='PATH', type=FileType('w', encoding='ascii'),
        default='-',
        help=(
            "Write configuration header to PATH, or '-' (the default) for "
            "standard output.")
    )
    args = parser.parse_args()
    if int(args.static) + int(args.config) != 1:
        raise Fail("Pass exactly one of '--static' and '--config'.")
    return args


def iterate_entries(instream):
    """Iterate pairs of standard C++ and libpqxx feature macros."""
    for line in instream:
        yield line.strip().split()


VAR_PATTERN = "auto %s = %s;"


def generate_static(args):
    """Generate C++ code for running through the preprocessor."""
    entries = [
        line.strip().split()
        for line in args.input
    ]
    script = os.path.basename(__file__)
    print(f"// Feature tests generated by {script}.", file=args.output)
    print("#include <version>", file=args.output)
    for cxx_macro, pqxx_macro in entries:
        print(f"#if defined({cxx_macro}) && {cxx_macro}", file=args.output)
        print(VAR_PATTERN % (pqxx_macro, 'true'), file=args.output)
        print("#else", file=args.output)
        print(VAR_PATTERN % (pqxx_macro, 'false'), file=args.output)
        print("#endif", file=args.output)


def generate_config(args):
    """Generate the ultimate config header from preprocessed source."""
    pattern = (VAR_PATTERN % ("([a-z_]+)", "([^;]+)")) + '$'
    for line in args.input:
        match = re.match(pattern, line)
        if match is not None:
            variable, value = match.groups()
            print(f"#define {variable} {value}", file=args.output)


def main():
    """Main entry point."""
    try:
        args = parse_args()
        if args.static:
            generate_static(args)
        else:
            generate_config(args)
        args.output.flush()
        args.output.close()
    except Fail as error:
        print(error, file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
